<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="Description" content="HIPI - Hadoop Image Processing Interface is a Hadoop MapReduce library for performing image processing tasks in the Hadoop distributed computation framework." />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    
    <link rel="stylesheet" type="text/css" href="include/main.css" />
    <link rel="stylesheet" type="text/css" href="include/javasyntax.css" />
    <title>HIPI - Hadoop Image Processing Interface :: Introduction</title>
  </head>
  
  <body>
    <div class="header">
      <h1>HIPI - Hadoop Image Processing Framework</h1>
    </div>
    <div class="navigation_menu">
      <ul>
	<li><a href="index.html">Introduction</a></li>
	<li><a href="gettingstarted.html">Getting Started</a></li>
	<li><a href="documentation.html">Documentation</a></li>
	<li><a href="examples.html">Examples</a></li>
	<li><a href="downloads.html">Downloads</a></li>
	<li><a href="about.html">About</a></li>
      </ul>
    </div>
    
    <!-- Begin Content -->
    <div class="content">
      <h2>Overview</h2>
      <div class="section">
	HIPI is a library for <a class="external_link"
	href="http://hadoop.apache.org/mapreduce">Hadoop's
	MapReduce</a> framework that provides an API for performing
	image processing tasks in a distributed computing
	environment. Here is an overview of our system:
	
	<img class="centered_image" src="images/hipi_pipeline.png" width="700" alt=""/>
	
	The input type used in HIPI is referred to as a <a
	href="">HipiImageBundle</a> (HIB). A HIB is a set of images
	combined into one large file along with some metadata
	describing the layout of the images. A HIB can be created from
	an already existing set of images or directly through some
	other source (e.g. our <a href="">DistributedDownloader</a>). <br /><br />

	In order to improve the efficiency of some jobs, HIPI allows a
	user to specify a culling function that discards images that
	do not meet a specified set of criteria (e.g. the image must
	be less than 10 megapixels). The user-specified <a
	href="">CullMapper</a> class is then invoked on each image
	that passes the culling test. Images are presented to this
	class as a <a href="">FloatImage</a> and an associated <a
	href="">ImageHeader</a>. Although HIPI does not directly
	modify any of the default Hadoop MapReduce behavior once the
	Mapper's take over, a user can modify execution parameters
	specific to image processing tasks through the <a
	href="">HipiJob</a> object during setup.  <br /><br />

	Great care has been taken to ensure that the implementations
	of the necessary components of Hadoop MapReduce are efficient
	and effective for image processing tasks. Please see our <a
	href="experiments.html">Experiments</a> section for further
	analysis of HIPI.
      </div>
      
      <h2>The Four Main Classes</h2>
      <div class="section">
	The classes most frequently used by a practitioner are the <a
	href="">HipiImageBundle</a>, the <a href="">FloatImage</a>,
	and the <a href="">CullMapper</a> classes. These classes
	provide most of the functionality an average user will need
	and are described briefly below. The full API for HIPI can be
	found on our <a href="documentation.html">documentation</a>
	page.
	
	<h3>HIPI Image Bundle (HIB)</h3> 
	
	A HIPI Image Bundle (HIB) is a collection of images that are
	stored together in one file, somewhat analagous to .tar files
	in UNIX. HIBs are implemented via the <a
	href="">HipiImageBundle</a> class and can be used directly in
	the Hadoop MapReduce framework. Several common operations can
	be performed on HIBs, including:
	<ul>
	  <li>
	    Create a HIB
	    <pre id="Classes">
  Configuration conf = <font id="New">new</font> Configuration();
  HipiImageBundle hib = <font id="New">new</font> HipiImageBundle(<font id="New">new</font> Path(<font id="StringLiteral">"/path/to/file.hib"</font>), conf);
  hib.open(AbstractImageBundle.FILE_MODE_WRITE, <font id="True">true</font>);
  ...
	    </pre>
	  </li>
	  <li>
	    Add images to an already existing HIB
	    <pre id="Classes">
  File file = <font id="New">new</font> File(<font id="StringLiteral">"/path/to/file.jpg"</font>);
  FileInputStream fis = <font id="New">new</font> FileInputStream(file);
  hib.addImage(fis, ImageType.JPEG_IMAGE);
  ...
	    </pre>
	  </li>
	  <li>
	    Merge two HIBs
	    <pre id="Classes">
  Path temp_path = <font id="New">new</font> Path(<font id="StringLiteral">"/path/to/file.hib"</font>);
  HipiImageBundle input_bundle = <font id="New">new</font> HipiImageBundle(temp_path, conf);
  hib.append(input_bundle);
  ...
	    </pre>
	  </li>
	  <li>
	    Read the images from a HIB (random access is permitted
	    through <a href="">HipiImageBundle.FileReader</a>)
	    <pre id="Classes">
  <font id="While">while</font> (hib.prepareNext()) {
  	ImageHeader imageHeader = hib.readHeader();
	FloatImage image = hib.readImage();
	...
  }
  hib.close();
	    </pre>
	  </li>
	</ul>
	<div class="important">Important Note:</div>
	HIBs must be opened in either FILE_MODE_READ or
	FILE_MODE_WRITE mode (see <a
	href="">AbstractImageBundle::open</a>), and once they have
	been opened in one mode, the mode cannot be switched.  <br
	/><br />

	<div class="important">Important Note:</div> When creating a
	HIB through the <a href="">HipiImageBundle::create</a> method,
	you can specify an optional parameter called blockSize. This
	parameter is very important as it controls the way a HIB will
	be distributed to the map
	tasks. The <a href="">ImageBundleInputFormat</a> splits a HIB
	into sections based on the block size of the HIB itself in
	order to most effectively distirbute the job. However, if the
	block size is set too large, then a small number of machines
	will be processing all of the images in the HIB. Therefore it
	is advised that the block size be set such that the number of
	blocks the entire HIB spans is roughly the number of nodes in
	the cluster.<br /><br />

	You can create a HIPI Image Bundle from a set of files using
	the operations listed above, or via some external source
	(e.g. Flickr) via
	our <a href="">DistributedDownloader</a>. Please see
	the <a href="">HIB javadoc page</a> for more details on all of
	the HIB operations, and the <a href="">Experiments</a> page
	for information regarding the design of HIBs.
	
	<h3>Float Image</h3>
	
	The primary input to Map tasks in HIPI is
	the <a href="">FloatImage</a> class. It is a simple
	representation of an image file as a set of pixels specified
	with single floating-point precision. Several common
	operations can be performed on a FloatImage:
	<div class="todo">TODO: Show small code snippets for each of these</div>
	<ul>
	  <li>Get/set pixels values</li>
	  <li>Convert to grayscale</li>
	  <li>Scalar multiplication</li>
	  <li>Addition</li>
	  <li>Image cropping</li>
	</ul>

	A <a href="">FloatImage</a> is actually just a three-dimensional set of
	floating-point values. Thus it can also be treated as a matrix
	(or tensor) and used accordingly. The function
	<a href="">FloatImage::getData</a> converts the FloatImage
	into its array representation and can be used directly with
	the popular BLAS/LAPACK Java implementation
	<a class="external_link"
	href="http://icl.cs.utk.edu/f2j/">f2j</a> to perform standard
	matrix operations. Creating a FloatImage from an array of
	pixels can be performed via a special form of
	the <a href="">FloatImage constructor</a>. <br /><br />

	As mentioned in the <a href="#overview">Overview</a> section,
	HIPI takes as input a <a href="#hib">HIPI Image Bundle</a> and
	sends records (key-value pairs) to user-specified Mapper
	functions with the key being an object of
	type <a href="">ImageHeader</a> and the value being an object
	of type <a href="">FloatImage</a>. For each image contained in
	the HIB that passes the optional <a href="#culling">culling
	step</a> one such record will be generated.
	
	<h3>Cull Mapper</h3>
	
	HIPI provides a way for users to discard, or cull, images that
	do not meet a set of criteria. The CullMapper class defines a
	special type of Hadoop Mapper that contains an extra function
	CullMapper::cull that can be used to test an ImageHeader
	associated with a FloatImage for arbitrary
	criteria. <br /><br />

	In the example below, the CullMapper is being used (which
	inherits directly from Mapper) to process images taken with a
	Canon PowerShot S500 digital camera and having dimensions 2592
	by 1944. The function CullMapper::cull returns a boolean
	indicating whether the image described by ImageHeader should
	be discarded (true) or should be processed (false);

	<pre id="Classes">
    <font id="Public">public</font> <font id="Static">static</font> <font id="Class">class</font> MyMapper <font id="Extends">extends</font> CullMapper&lt;ImageHeader, FloatImage, NullWritable, FloatImage&gt;
    {       
        <font id="Public">public</font> <font id="Boolean">boolean</font> cull(ImageHeader key) <font id="Throws">throws</font> IOException, InterruptedException {
            <font id="If">if</font>(key.getEXIFInformation(<font id="StringLiteral">"Model"</font>).equals(<font id="StringLiteral">"Canon PowerShot S500"</font>) &amp;&amp; key.width == <font id="IntegerLiteral">2592</font> &amp;&amp; key.height == <font id="IntegerLiteral">1944</font>)
                <font id="Return">return</font> <font id="False">false</font>;
            <font id="Else">else</font>
                <font id="Return">return</font> <font id="True">true</font>;
        }
        
        <font id="Public">public</font> <font id="Void">void</font> map(ImageHeader key, FloatImage value, Context context) <font id="Throws">throws</font> IOException, InterruptedException {
	...
	</pre>
	
	<h3>HIPI Job</h3>
	
	HIPI provides a useful extension of the standard
	Hadoop <a href="">Job</a> class that allows a user to set
	parameters that are common in scenarios where HIPI would be
	used. The two main operations that can be performed using a
	<a href="">HipiJob</a> are:
	<ul>
	  <li>Enable/disable speculative execution</li>
	  <li>Enable/disable compression of Map output records</li>
	</ul>
	The former method
	(<a href="">HipiJob::set{Map,Reduce}SpeculativeExecution</a>)
	controls whether Hadoop should run multiple instances of
	the <em>the same</em> Map task to potentially increase
	performance. Whether this is a good idea is specific to the
	application, but in general, this should be enabled. This
	ensures that if a particular node in the Hadoop cluster is
	experiencing performance degradation, the entire job will not
	be affected. Hadoop will automatically kill the slower task,
	and use the output from a different instance. Of course this
	incurs the overhead of spawning more tasks than is actually
	needed.  <br /><br />
	
	The second operation
	(<a href="">HipiJob::setCompressMapOutput</a>) enables or
	disables compression of the output records from the Map tasks
	before they are sent to the Reduce tasks. This option should
	be enabled if there is a significant amount of data being
	transfered between the two sets of tasks. Note that the
	efficacy of this approach is controlled implicitly by how well
	the records can be compressed and the relationship between the
	size of the records, the bandwidth of the cluster, and the
	time spend compressing and decompressing the files.

      </div>
      
      <h2>Examples</h2>
      <div class="section">
	All of our examples can be found on
	the <a href="examples.html">examples</a> page.
      </div>

    </div>
    <!-- End Content -->
  </body>
</html>
